<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ariadne.adapter API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ariadne.adapter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import abc
import asyncio
import functools
import json
from asyncio.events import AbstractEventLoop
from asyncio.exceptions import CancelledError
from asyncio.locks import Event
from asyncio.queues import Queue
from asyncio.tasks import Task
from typing import (
    TYPE_CHECKING,
    Any,
    AsyncGenerator,
    Awaitable,
    Callable,
    Dict,
    Optional,
    Set,
    Union,
)

import aiohttp.web_exceptions
from aiohttp import ClientSession, FormData
from aiohttp.client_ws import ClientWebSocketResponse
from aiohttp.http_websocket import WSMsgType
from graia.broadcast import Broadcast
from graia.broadcast.entities.event import Dispatchable
from loguru import logger
from typing_extensions import Concatenate
from yarl import URL

from .event import MiraiEvent
from .event.network import RemoteException
from .exception import InvalidArgument, InvalidSession, NotSupportedAction
from .model import CallMethod, DatetimeEncoder, MiraiSession
from .util import await_predicate, validate_response, yield_with_timeout

if TYPE_CHECKING:
    from .typing import P, R, Self


def require_verified(
    func: &#34;Callable[Concatenate[Adapter, P], R]&#34;,
) -&gt; &#34;Callable[Concatenate[Adapter, P], R]&#34;:
    @functools.wraps(func)
    def wrapper(self: &#34;Adapter&#34;, *args: &#34;P.args&#34;, **kwargs: &#34;P.kwargs&#34;) -&gt; &#34;R&#34;:
        if not self.mirai_session.session_key:
            raise InvalidSession(&#34;you must verify the session before action.&#34;)
        return func(self, *args, **kwargs)

    return wrapper


def error_wrapper(
    network_action_callable: &#34;Callable[Concatenate[Self, P], Awaitable[R]]&#34;,
) -&gt; &#34;Callable[Concatenate[Self, P], Awaitable[R]]&#34;:
    @functools.wraps(network_action_callable)
    async def wrapped_network_action_callable(self: &#34;Adapter&#34;, *args: &#34;P.args&#34;, **kwargs: &#34;P.kwargs&#34;) -&gt; &#34;R&#34;:
        running_count = 0

        while running_count &lt; 5:
            running_count += 1
            try:
                result = await network_action_callable(self, *args, **kwargs)
            except InvalidSession as invalid_session_exc:
                logger.error(&#34;Invalid session detected, asking daemon to restart adapter...&#34;)
                logger.exception(invalid_session_exc)
                await self.stop()
            except aiohttp.web_exceptions.HTTPNotFound:
                raise NotSupportedAction(f&#34;{network_action_callable.__name__}: this action not supported&#34;)
            except aiohttp.web_exceptions.HTTPInternalServerError as e:
                self.broadcast.postEvent(RemoteException())
                logger.error(&#34;An exception has thrown by remote, please check the console!&#34;)
                raise
            except (
                aiohttp.web_exceptions.HTTPMethodNotAllowed,
                aiohttp.web_exceptions.HTTPRequestURITooLong,
                aiohttp.web_exceptions.HTTPTooManyRequests,
            ):

                logger.error(
                    f&#34;It seems that we post in a wrong way &#34;
                    f&#34;for the action &#39;{network_action_callable.__name__}&#39;, please open a issue.&#34;
                )
                raise
            except aiohttp.web_exceptions.HTTPRequestTimeout:
                logger.error(
                    f&#34;timeout on {network_action_callable.__name__}, retry after 5 seconds...&#34;.format()
                )
                await asyncio.sleep(5)
                raise
            else:
                return result
        raise TimeoutError(f&#34;Failed after 5 try on {network_action_callable.__name__}.&#34;)

    return wrapped_network_action_callable


class Adapter(abc.ABC):
    &#34;&#34;&#34;
    适配器抽象基类.

    Args:
        broadcast(Broadcast): Broadcast 实例
        session: Session 实例, 存储了连接信息
    &#34;&#34;&#34;

    def __init__(self, broadcast: Broadcast, mirai_session: MiraiSession, log: bool = True) -&gt; None:
        self.broadcast = broadcast
        self.loop: AbstractEventLoop = broadcast.loop
        self.running: bool = False
        self.mirai_session: MiraiSession = mirai_session
        self.session: Optional[ClientSession] = None
        self.fetch_task: Optional[Task] = None
        self.queue: Optional[Queue[Dispatchable]] = None
        self.log: bool = log

    @abc.abstractmethod
    async def fetch_cycle(self) -&gt; None:
        &#34;&#34;&#34;
        负责接收并处理数据, 向事件队列发送事件.
        &#34;&#34;&#34;
        self.running = True
        self.session = ClientSession()
        if not self.queue:
            self.queue = Queue()
        while self.running:
            await self.queue.put(Dispatchable())
        self.mirai_session.session_key = None
        await self.session.close()

    @abc.abstractmethod
    @require_verified
    @error_wrapper
    async def call_api(
        self, action: str, method: CallMethod, data: Optional[Union[dict, str]] = None
    ) -&gt; Union[dict, list]:
        &#34;&#34;&#34;
        向Mirai端发送数据.
        如有回复则应一并返回.

        Args:
            action (str): 要执行的操作.
            method (CallMethod): 指示对 mirai-api-http 端发送数据的方式.
            data (dict): 要发送的数据.
        Returns:
            dict: 响应字典.
        &#34;&#34;&#34;

    async def build_event(self, data: dict) -&gt; MiraiEvent:
        &#34;&#34;&#34;
        从尚未明确指定事件类型的对象中获取事件的定义, 并进行解析

        Args:
            data (dict): 用 dict 表示的序列化态事件, 应包含有字段 `type` 以供分析事件定义.

        Raises:
            InvalidArgument: 目标对象中不包含字段 `type`
            ValueError: 没有找到对应的字段, 通常的, 这意味着应用获取到了一个尚未被定义的事件, 请报告问题.

        Returns:
            MiraiEvent: 已经被序列化的事件
        &#34;&#34;&#34;
        event_type: Optional[str] = data.get(&#34;type&#34;)
        if not event_type or not isinstance(event_type, str):
            raise InvalidArgument(&#34;Unable to find &#39;type&#39; field for automatic parsing&#34;)
        event_class: Optional[MiraiEvent] = self.broadcast.findEvent(event_type)  # type: ignore
        if not event_class:
            logger.error(&#34;An event is not recognized! Please report with your log to help us diagnose.&#34;)
            raise ValueError(f&#34;Unable to find event: {event_type}&#34;, data)
        data = {k: v for k, v in data.items() if k != &#34;type&#34;}
        event = event_class.parse_obj(data)
        return event

    @property
    def session_activated(self) -&gt; bool:
        return bool(self.mirai_session.session_key)

    async def start(self):
        if not self.running:
            self.fetch_task = asyncio.create_task(self.fetch_cycle())
            await await_predicate(lambda: self.running)

    async def stop(self):
        if self.running:
            self.running = False
            await self.fetch_task
            self.fetch_task = None


class HttpAdapter(Adapter):
    &#34;&#34;&#34;
    仅使用正向 HTTP 的适配器, 采用短轮询接收事件/消息.
    不推荐.
    Note: Working In Progress
    &#34;&#34;&#34;

    def __init__(
        self,
        broadcast: Broadcast,
        mirai_session: MiraiSession,
        fetch_interval: float = 0.5,
    ) -&gt; None:
        super().__init__(broadcast, mirai_session)
        self.fetch_interval = fetch_interval
        raise NotImplementedError(&#34;HTTP Adapter is not supported yet!&#34;)

    async def fetch_cycle(self) -&gt; None:
        self.running = True
        self.session = ClientSession()
        if not self.queue:
            self.queue = Queue()
        while self.running:
            await asyncio.sleep(self.fetch_interval)
        self.mirai_session.session_key = None
        await self.session.close()

    @require_verified
    @error_wrapper
    async def call_api(
        self,
        action: str,
        method: CallMethod,
        data: Optional[Union[Dict[str, Any], str]] = None,
    ) -&gt; Union[dict, list]:
        if not data:
            data = dict()
        if not self.session:
            raise RuntimeError(&#34;Unable to get session!&#34;)

        if method == CallMethod.GET or method == CallMethod.RESTGET:
            if isinstance(data, str):
                data = json.loads(data)
            async with self.session.get(URL(self.mirai_session.url_gen(action)).with_query(data)) as response:
                response.raise_for_status()
                resp_json: dict = await response.json()

        elif method == CallMethod.POST or method == CallMethod.RESTPOST:
            if not isinstance(data, str):
                data = json.dumps(data, cls=DatetimeEncoder)
            async with self.session.post(self.mirai_session.url_gen(action), data=data) as response:
                response.raise_for_status()
                resp_json: dict = await response.json()

        else:  # MULTIPART
            form = FormData()
            if not isinstance(data, dict):
                raise ValueError(&#34;Data must be a dict in multipart call!&#34;)
            for k, v in data.items():
                form.add_fields(k, v)
            async with self.session.post(self.mirai_session.url_gen(action), data=form) as response:
                response.raise_for_status()
                resp_json: dict = await response.json()
        if &#34;data&#34; in resp_json:
            resp = resp_json[&#34;data&#34;]
        else:
            resp = resp_json

        validate_response(resp)
        return resp


class WebsocketAdapter(Adapter):
    &#34;&#34;&#34;
    仅使用正向 Websocket 的适配器.
    因 Mirai API HTTP 的实现, 部分功能不可用.
    &#34;&#34;&#34;

    class SyncIdManager:
        allocated: Set[int] = {0}

        @classmethod
        def allocate(cls) -&gt; int:
            new_id = max(cls.allocated) + 1
            cls.allocated.add(new_id)
            return new_id

        @classmethod
        def done(cls, sync_id: int) -&gt; None:
            if sync_id in cls.allocated:
                cls.allocated.remove(sync_id)

    class CallResponse(Event):
        def __init__(self, *, loop: AbstractEventLoop = None) -&gt; None:
            super().__init__(loop=loop)
            self.response: Optional[dict] = None

    def __init__(self, broadcast: Broadcast, mirai_session: MiraiSession, ping: bool = True) -&gt; None:
        super().__init__(broadcast, mirai_session)
        self.ping = ping
        self.ping_task: Optional[Task] = None
        self.ws_conn: Optional[ClientWebSocketResponse] = None
        self.query_dict = {&#34;verifyKey&#34;: mirai_session.verify_key}
        self.sync_event: Dict[int, WebsocketAdapter.CallResponse] = {}
        if not mirai_session.single_mode:
            self.query_dict[&#34;qq&#34;] = mirai_session.account

    async def ws_ping(self, interval: float = 30.0) -&gt; None:
        while self.running:
            try:
                try:
                    await self.ws_conn.ping()
                    if self.log:
                        logger.debug(&#34;websocket: ping&#34;)
                except Exception as e:
                    logger.exception(f&#34;websocket: ping failed: {e!r}&#34;)
                else:
                    if self.log:
                        logger.debug(f&#34;websocket: ping success, delay {interval}s&#34;)
                    await asyncio.sleep(interval)
            except asyncio.CancelledError:
                if self.log:
                    logger.debug(&#34;websocket: pinger exit&#34;)
                break

    @require_verified
    @error_wrapper
    async def call_api(
        self, action: str, method: CallMethod, data: Optional[Union[dict, str]] = None
    ) -&gt; Union[dict, list]:
        data = data or dict()
        if not self.ws_conn:
            raise ValueError(&#34;no existing websocket connection&#34;)
        sync_id = self.SyncIdManager.allocate()
        event = self.CallResponse()
        self.sync_event[sync_id] = event
        content = {
            &#34;syncId&#34;: sync_id,
            &#34;command&#34;: action,
            &#34;content&#34;: data,
        }
        if method == CallMethod.RESTGET:
            content[&#34;subCommand&#34;] = &#34;get&#34;
        elif method == CallMethod.RESTPOST:
            content[&#34;subCommand&#34;] = &#34;update&#34;
        elif method == CallMethod.MULTIPART:
            raise NotImplementedError(f&#34;Unsupported operation for WebsocketAdapter: {method}&#34;)

        await self.ws_conn.send_str(json.dumps(content, cls=DatetimeEncoder))
        logger.debug(f&#34;websocket：sent with sync id: {sync_id}&#34;)
        await event.wait()
        self.SyncIdManager.done(sync_id)
        value: dict = event.response
        del self.sync_event[sync_id]
        del event
        validate_response(value)
        if &#34;data&#34; in value:
            return value[&#34;data&#34;]
        return value

    async def raw_data_parser(self, raw_data: dict) -&gt; Optional[Dispatchable]:
        sync_id: str = raw_data[&#34;syncId&#34;]
        received_data: dict = raw_data[&#34;data&#34;]
        validate_response(received_data)
        if not self.mirai_session.session_key:
            if session_key := received_data.get(&#34;session&#34;, None):
                self.mirai_session.session_key = session_key
            return
        sync_id = int(sync_id)
        if sync_id not in self.SyncIdManager.allocated:
            event = await self.build_event(received_data)
            return event
        else:
            if sync_id in self.sync_event:
                response = self.sync_event[sync_id]
                response.response = received_data
                response.set()

    async def fetch_cycle(self) -&gt; None:
        self.session = ClientSession()
        self.running = True
        if not self.queue:
            self.queue = Queue()
        async with self.session.ws_connect(
            str(URL(self.mirai_session.url_gen(&#34;all&#34;)).with_query(self.query_dict)),
            autoping=False,
        ) as connection:
            logger.info(&#34;websocket: connected&#34;)
            self.ws_conn = connection

            if self.ping:
                self.ping_task = self.loop.create_task(self.ws_ping(), name=&#34;ariadne_adapter_ws_ping&#34;)
                logger.info(&#34;websocket: ping task created&#34;)
            try:
                async for ws_message in yield_with_timeout(connection.receive, lambda: self.running):
                    if ws_message.type is WSMsgType.TEXT:
                        original_data: dict = json.loads(ws_message.data)
                        event = await self.raw_data_parser(original_data)
                        if event:
                            await self.queue.put(event)
                    elif ws_message.type is WSMsgType.CLOSED:
                        logger.warning(&#34;websocket: connection has been closed.&#34;)
                        return
                    elif ws_message.type is WSMsgType.PONG:
                        if self.log:
                            logger.debug(&#34;websocket: received pong&#34;)
                    else:
                        logger.warning(&#34;websocket: unknown message type - {}&#34;.format(ws_message.type))
            except Exception as e:
                logger.exception(e)
            finally:
                if self.ping_task:
                    self.ping_task.cancel()
                    self.ping_task = None
                    if self.log:
                        logger.debug(&#34;websocket: ping task complete&#34;)
        logger.info(&#34;websocket: disconnected&#34;)
        self.mirai_session.session_key = None
        await self.session.close()


class CombinedAdapter(Adapter):
    &#34;&#34;&#34;
    使用正向Websocket接收事件与消息, 用HTTP发送消息/操作的适配器.
    稳定与性能的平衡, 但需要 Mirai API HTTP 同时启用 `http` 与 `ws` 适配器.

    Args:
        bcc(Broadcast): Broadcast 实例
        session: Session 实例, 存储了连接信息
        ping(bool): 是否启用 ping 功能.
    &#34;&#34;&#34;

    def __init__(
        self, broadcast: Broadcast, mirai_session: MiraiSession, ping: bool = True, log: bool = True
    ) -&gt; None:
        super().__init__(broadcast, mirai_session, log)
        self.ping = ping
        self.ping_task: Optional[Task] = None
        self.ws_conn: Optional[ClientWebSocketResponse] = None
        self.query_dict = {&#34;verifyKey&#34;: mirai_session.verify_key}
        if not mirai_session.single_mode:
            self.query_dict[&#34;qq&#34;] = mirai_session.account

    ws_ping = WebsocketAdapter.ws_ping

    call_api = HttpAdapter.call_api

    async def raw_data_parser(self, raw_data: dict) -&gt; Optional[Dispatchable]:
        received_data = raw_data[&#34;data&#34;]
        validate_response(received_data)
        if session_key := received_data.get(&#34;session&#34;, None):
            self.mirai_session.session_key = session_key
            return
        event = await self.build_event(received_data)
        return event

    fetch_cycle = WebsocketAdapter.fetch_cycle


DefaultAdapter = CombinedAdapter


class DebugAdapter(DefaultAdapter):
    &#34;&#34;&#34;
    Debugging adapter
    &#34;&#34;&#34;

    async def build_event(self, data: dict) -&gt; MiraiEvent:
        &#34;&#34;&#34;
        从尚未明确指定事件类型的对象中获取事件的定义, 并进行解析

        Args:
            data (dict): 用 dict 表示的序列化态事件, 应包含有字段 `type` 以供分析事件定义.

        Raises:
            InvalidArgument: 目标对象中不包含字段 `type`
            ValueError: 没有找到对应的字段, 通常的, 这意味着应用获取到了一个尚未被定义的事件, 请报告问题.

        Returns:
            MiraiEvent: 已经被序列化的事件
        &#34;&#34;&#34;
        try:
            event = await super().build_event(data)
        except ValueError as e:
            logger.error(f&#34;{e.args[0]}\n{json.dumps(data, indent=4)}&#34;)
            raise
        else:
            logger.debug(event)
            return event</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ariadne.adapter.error_wrapper"><code class="name flex">
<span>def <span class="ident">error_wrapper</span></span>(<span>network_action_callable: Callable[Concatenate[Self, P], Awaitable[R]]) ‑> Callable[Concatenate[Self, P], Awaitable[R]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_wrapper(
    network_action_callable: &#34;Callable[Concatenate[Self, P], Awaitable[R]]&#34;,
) -&gt; &#34;Callable[Concatenate[Self, P], Awaitable[R]]&#34;:
    @functools.wraps(network_action_callable)
    async def wrapped_network_action_callable(self: &#34;Adapter&#34;, *args: &#34;P.args&#34;, **kwargs: &#34;P.kwargs&#34;) -&gt; &#34;R&#34;:
        running_count = 0

        while running_count &lt; 5:
            running_count += 1
            try:
                result = await network_action_callable(self, *args, **kwargs)
            except InvalidSession as invalid_session_exc:
                logger.error(&#34;Invalid session detected, asking daemon to restart adapter...&#34;)
                logger.exception(invalid_session_exc)
                await self.stop()
            except aiohttp.web_exceptions.HTTPNotFound:
                raise NotSupportedAction(f&#34;{network_action_callable.__name__}: this action not supported&#34;)
            except aiohttp.web_exceptions.HTTPInternalServerError as e:
                self.broadcast.postEvent(RemoteException())
                logger.error(&#34;An exception has thrown by remote, please check the console!&#34;)
                raise
            except (
                aiohttp.web_exceptions.HTTPMethodNotAllowed,
                aiohttp.web_exceptions.HTTPRequestURITooLong,
                aiohttp.web_exceptions.HTTPTooManyRequests,
            ):

                logger.error(
                    f&#34;It seems that we post in a wrong way &#34;
                    f&#34;for the action &#39;{network_action_callable.__name__}&#39;, please open a issue.&#34;
                )
                raise
            except aiohttp.web_exceptions.HTTPRequestTimeout:
                logger.error(
                    f&#34;timeout on {network_action_callable.__name__}, retry after 5 seconds...&#34;.format()
                )
                await asyncio.sleep(5)
                raise
            else:
                return result
        raise TimeoutError(f&#34;Failed after 5 try on {network_action_callable.__name__}.&#34;)

    return wrapped_network_action_callable</code></pre>
</details>
</dd>
<dt id="ariadne.adapter.require_verified"><code class="name flex">
<span>def <span class="ident">require_verified</span></span>(<span>func: Callable[Concatenate[<a title="ariadne.adapter.Adapter" href="#ariadne.adapter.Adapter">Adapter</a>, P], R]) ‑> Callable[Concatenate[<a title="ariadne.adapter.Adapter" href="#ariadne.adapter.Adapter">Adapter</a>, P], R]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def require_verified(
    func: &#34;Callable[Concatenate[Adapter, P], R]&#34;,
) -&gt; &#34;Callable[Concatenate[Adapter, P], R]&#34;:
    @functools.wraps(func)
    def wrapper(self: &#34;Adapter&#34;, *args: &#34;P.args&#34;, **kwargs: &#34;P.kwargs&#34;) -&gt; &#34;R&#34;:
        if not self.mirai_session.session_key:
            raise InvalidSession(&#34;you must verify the session before action.&#34;)
        return func(self, *args, **kwargs)

    return wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ariadne.adapter.Adapter"><code class="flex name class">
<span>class <span class="ident">Adapter</span></span>
<span>(</span><span>broadcast: graia.broadcast.Broadcast, mirai_session: <a title="ariadne.model.MiraiSession" href="model.html#ariadne.model.MiraiSession">MiraiSession</a>, log: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>适配器抽象基类.</p>
<h2 id="args">Args</h2>
<dl>
<dt>broadcast(Broadcast): Broadcast 实例</dt>
<dt><strong><code>session</code></strong></dt>
<dd>Session 实例, 存储了连接信息</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Adapter(abc.ABC):
    &#34;&#34;&#34;
    适配器抽象基类.

    Args:
        broadcast(Broadcast): Broadcast 实例
        session: Session 实例, 存储了连接信息
    &#34;&#34;&#34;

    def __init__(self, broadcast: Broadcast, mirai_session: MiraiSession, log: bool = True) -&gt; None:
        self.broadcast = broadcast
        self.loop: AbstractEventLoop = broadcast.loop
        self.running: bool = False
        self.mirai_session: MiraiSession = mirai_session
        self.session: Optional[ClientSession] = None
        self.fetch_task: Optional[Task] = None
        self.queue: Optional[Queue[Dispatchable]] = None
        self.log: bool = log

    @abc.abstractmethod
    async def fetch_cycle(self) -&gt; None:
        &#34;&#34;&#34;
        负责接收并处理数据, 向事件队列发送事件.
        &#34;&#34;&#34;
        self.running = True
        self.session = ClientSession()
        if not self.queue:
            self.queue = Queue()
        while self.running:
            await self.queue.put(Dispatchable())
        self.mirai_session.session_key = None
        await self.session.close()

    @abc.abstractmethod
    @require_verified
    @error_wrapper
    async def call_api(
        self, action: str, method: CallMethod, data: Optional[Union[dict, str]] = None
    ) -&gt; Union[dict, list]:
        &#34;&#34;&#34;
        向Mirai端发送数据.
        如有回复则应一并返回.

        Args:
            action (str): 要执行的操作.
            method (CallMethod): 指示对 mirai-api-http 端发送数据的方式.
            data (dict): 要发送的数据.
        Returns:
            dict: 响应字典.
        &#34;&#34;&#34;

    async def build_event(self, data: dict) -&gt; MiraiEvent:
        &#34;&#34;&#34;
        从尚未明确指定事件类型的对象中获取事件的定义, 并进行解析

        Args:
            data (dict): 用 dict 表示的序列化态事件, 应包含有字段 `type` 以供分析事件定义.

        Raises:
            InvalidArgument: 目标对象中不包含字段 `type`
            ValueError: 没有找到对应的字段, 通常的, 这意味着应用获取到了一个尚未被定义的事件, 请报告问题.

        Returns:
            MiraiEvent: 已经被序列化的事件
        &#34;&#34;&#34;
        event_type: Optional[str] = data.get(&#34;type&#34;)
        if not event_type or not isinstance(event_type, str):
            raise InvalidArgument(&#34;Unable to find &#39;type&#39; field for automatic parsing&#34;)
        event_class: Optional[MiraiEvent] = self.broadcast.findEvent(event_type)  # type: ignore
        if not event_class:
            logger.error(&#34;An event is not recognized! Please report with your log to help us diagnose.&#34;)
            raise ValueError(f&#34;Unable to find event: {event_type}&#34;, data)
        data = {k: v for k, v in data.items() if k != &#34;type&#34;}
        event = event_class.parse_obj(data)
        return event

    @property
    def session_activated(self) -&gt; bool:
        return bool(self.mirai_session.session_key)

    async def start(self):
        if not self.running:
            self.fetch_task = asyncio.create_task(self.fetch_cycle())
            await await_predicate(lambda: self.running)

    async def stop(self):
        if self.running:
            self.running = False
            await self.fetch_task
            self.fetch_task = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ariadne.adapter.CombinedAdapter" href="#ariadne.adapter.CombinedAdapter">CombinedAdapter</a></li>
<li><a title="ariadne.adapter.HttpAdapter" href="#ariadne.adapter.HttpAdapter">HttpAdapter</a></li>
<li><a title="ariadne.adapter.WebsocketAdapter" href="#ariadne.adapter.WebsocketAdapter">WebsocketAdapter</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ariadne.adapter.Adapter.session_activated"><code class="name">var <span class="ident">session_activated</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def session_activated(self) -&gt; bool:
    return bool(self.mirai_session.session_key)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ariadne.adapter.Adapter.build_event"><code class="name flex">
<span>async def <span class="ident">build_event</span></span>(<span>self, data: dict) ‑> <a title="ariadne.event.MiraiEvent" href="event/index.html#ariadne.event.MiraiEvent">MiraiEvent</a></span>
</code></dt>
<dd>
<div class="desc"><p>从尚未明确指定事件类型的对象中获取事件的定义, 并进行解析</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>用 dict 表示的序列化态事件, 应包含有字段 <code>type</code> 以供分析事件定义.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InvalidArgument</code></dt>
<dd>目标对象中不包含字段 <code>type</code></dd>
<dt><code>ValueError</code></dt>
<dd>没有找到对应的字段, 通常的, 这意味着应用获取到了一个尚未被定义的事件, 请报告问题.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>MiraiEvent</code></dt>
<dd>已经被序列化的事件</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def build_event(self, data: dict) -&gt; MiraiEvent:
    &#34;&#34;&#34;
    从尚未明确指定事件类型的对象中获取事件的定义, 并进行解析

    Args:
        data (dict): 用 dict 表示的序列化态事件, 应包含有字段 `type` 以供分析事件定义.

    Raises:
        InvalidArgument: 目标对象中不包含字段 `type`
        ValueError: 没有找到对应的字段, 通常的, 这意味着应用获取到了一个尚未被定义的事件, 请报告问题.

    Returns:
        MiraiEvent: 已经被序列化的事件
    &#34;&#34;&#34;
    event_type: Optional[str] = data.get(&#34;type&#34;)
    if not event_type or not isinstance(event_type, str):
        raise InvalidArgument(&#34;Unable to find &#39;type&#39; field for automatic parsing&#34;)
    event_class: Optional[MiraiEvent] = self.broadcast.findEvent(event_type)  # type: ignore
    if not event_class:
        logger.error(&#34;An event is not recognized! Please report with your log to help us diagnose.&#34;)
        raise ValueError(f&#34;Unable to find event: {event_type}&#34;, data)
    data = {k: v for k, v in data.items() if k != &#34;type&#34;}
    event = event_class.parse_obj(data)
    return event</code></pre>
</details>
</dd>
<dt id="ariadne.adapter.Adapter.call_api"><code class="name flex">
<span>async def <span class="ident">call_api</span></span>(<span>self, action: str, method: <a title="ariadne.model.CallMethod" href="model.html#ariadne.model.CallMethod">CallMethod</a>, data: Union[dict, str, ForwardRef(None)] = None) ‑> Union[dict, list]</span>
</code></dt>
<dd>
<div class="desc"><p>向Mirai端发送数据.
如有回复则应一并返回.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>要执行的操作.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>CallMethod</code></dt>
<dd>指示对 mirai-api-http 端发送数据的方式.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>要发送的数据.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>响应字典.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
@require_verified
@error_wrapper
async def call_api(
    self, action: str, method: CallMethod, data: Optional[Union[dict, str]] = None
) -&gt; Union[dict, list]:
    &#34;&#34;&#34;
    向Mirai端发送数据.
    如有回复则应一并返回.

    Args:
        action (str): 要执行的操作.
        method (CallMethod): 指示对 mirai-api-http 端发送数据的方式.
        data (dict): 要发送的数据.
    Returns:
        dict: 响应字典.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="ariadne.adapter.Adapter.fetch_cycle"><code class="name flex">
<span>async def <span class="ident">fetch_cycle</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>负责接收并处理数据, 向事件队列发送事件.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_cycle(self) -&gt; None:
    &#34;&#34;&#34;
    负责接收并处理数据, 向事件队列发送事件.
    &#34;&#34;&#34;
    self.running = True
    self.session = ClientSession()
    if not self.queue:
        self.queue = Queue()
    while self.running:
        await self.queue.put(Dispatchable())
    self.mirai_session.session_key = None
    await self.session.close()</code></pre>
</details>
</dd>
<dt id="ariadne.adapter.Adapter.start"><code class="name flex">
<span>async def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start(self):
    if not self.running:
        self.fetch_task = asyncio.create_task(self.fetch_cycle())
        await await_predicate(lambda: self.running)</code></pre>
</details>
</dd>
<dt id="ariadne.adapter.Adapter.stop"><code class="name flex">
<span>async def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def stop(self):
    if self.running:
        self.running = False
        await self.fetch_task
        self.fetch_task = None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ariadne.adapter.CombinedAdapter"><code class="flex name class">
<span>class <span class="ident">CombinedAdapter</span></span>
<span>(</span><span>broadcast: graia.broadcast.Broadcast, mirai_session: <a title="ariadne.model.MiraiSession" href="model.html#ariadne.model.MiraiSession">MiraiSession</a>, ping: bool = True, log: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>使用正向Websocket接收事件与消息, 用HTTP发送消息/操作的适配器.
稳定与性能的平衡, 但需要 Mirai API HTTP 同时启用 <code>http</code> 与 <code>ws</code> 适配器.</p>
<h2 id="args">Args</h2>
<dl>
<dt>bcc(Broadcast): Broadcast 实例</dt>
<dt><strong><code>session</code></strong></dt>
<dd>Session 实例, 存储了连接信息</dd>
</dl>
<p>ping(bool): 是否启用 ping 功能.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CombinedAdapter(Adapter):
    &#34;&#34;&#34;
    使用正向Websocket接收事件与消息, 用HTTP发送消息/操作的适配器.
    稳定与性能的平衡, 但需要 Mirai API HTTP 同时启用 `http` 与 `ws` 适配器.

    Args:
        bcc(Broadcast): Broadcast 实例
        session: Session 实例, 存储了连接信息
        ping(bool): 是否启用 ping 功能.
    &#34;&#34;&#34;

    def __init__(
        self, broadcast: Broadcast, mirai_session: MiraiSession, ping: bool = True, log: bool = True
    ) -&gt; None:
        super().__init__(broadcast, mirai_session, log)
        self.ping = ping
        self.ping_task: Optional[Task] = None
        self.ws_conn: Optional[ClientWebSocketResponse] = None
        self.query_dict = {&#34;verifyKey&#34;: mirai_session.verify_key}
        if not mirai_session.single_mode:
            self.query_dict[&#34;qq&#34;] = mirai_session.account

    ws_ping = WebsocketAdapter.ws_ping

    call_api = HttpAdapter.call_api

    async def raw_data_parser(self, raw_data: dict) -&gt; Optional[Dispatchable]:
        received_data = raw_data[&#34;data&#34;]
        validate_response(received_data)
        if session_key := received_data.get(&#34;session&#34;, None):
            self.mirai_session.session_key = session_key
            return
        event = await self.build_event(received_data)
        return event

    fetch_cycle = WebsocketAdapter.fetch_cycle</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ariadne.adapter.Adapter" href="#ariadne.adapter.Adapter">Adapter</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ariadne.adapter.DebugAdapter" href="#ariadne.adapter.DebugAdapter">DebugAdapter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ariadne.adapter.CombinedAdapter.call_api"><code class="name flex">
<span>async def <span class="ident">call_api</span></span>(<span>self, action: str, method: <a title="ariadne.model.CallMethod" href="model.html#ariadne.model.CallMethod">CallMethod</a>, data: Union[Dict[str, Any], str, ForwardRef(None)] = None) ‑> Union[dict, list]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_verified
@error_wrapper
async def call_api(
    self,
    action: str,
    method: CallMethod,
    data: Optional[Union[Dict[str, Any], str]] = None,
) -&gt; Union[dict, list]:
    if not data:
        data = dict()
    if not self.session:
        raise RuntimeError(&#34;Unable to get session!&#34;)

    if method == CallMethod.GET or method == CallMethod.RESTGET:
        if isinstance(data, str):
            data = json.loads(data)
        async with self.session.get(URL(self.mirai_session.url_gen(action)).with_query(data)) as response:
            response.raise_for_status()
            resp_json: dict = await response.json()

    elif method == CallMethod.POST or method == CallMethod.RESTPOST:
        if not isinstance(data, str):
            data = json.dumps(data, cls=DatetimeEncoder)
        async with self.session.post(self.mirai_session.url_gen(action), data=data) as response:
            response.raise_for_status()
            resp_json: dict = await response.json()

    else:  # MULTIPART
        form = FormData()
        if not isinstance(data, dict):
            raise ValueError(&#34;Data must be a dict in multipart call!&#34;)
        for k, v in data.items():
            form.add_fields(k, v)
        async with self.session.post(self.mirai_session.url_gen(action), data=form) as response:
            response.raise_for_status()
            resp_json: dict = await response.json()
    if &#34;data&#34; in resp_json:
        resp = resp_json[&#34;data&#34;]
    else:
        resp = resp_json

    validate_response(resp)
    return resp</code></pre>
</details>
</dd>
<dt id="ariadne.adapter.CombinedAdapter.fetch_cycle"><code class="name flex">
<span>async def <span class="ident">fetch_cycle</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>负责接收并处理数据, 向事件队列发送事件.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fetch_cycle(self) -&gt; None:
    self.session = ClientSession()
    self.running = True
    if not self.queue:
        self.queue = Queue()
    async with self.session.ws_connect(
        str(URL(self.mirai_session.url_gen(&#34;all&#34;)).with_query(self.query_dict)),
        autoping=False,
    ) as connection:
        logger.info(&#34;websocket: connected&#34;)
        self.ws_conn = connection

        if self.ping:
            self.ping_task = self.loop.create_task(self.ws_ping(), name=&#34;ariadne_adapter_ws_ping&#34;)
            logger.info(&#34;websocket: ping task created&#34;)
        try:
            async for ws_message in yield_with_timeout(connection.receive, lambda: self.running):
                if ws_message.type is WSMsgType.TEXT:
                    original_data: dict = json.loads(ws_message.data)
                    event = await self.raw_data_parser(original_data)
                    if event:
                        await self.queue.put(event)
                elif ws_message.type is WSMsgType.CLOSED:
                    logger.warning(&#34;websocket: connection has been closed.&#34;)
                    return
                elif ws_message.type is WSMsgType.PONG:
                    if self.log:
                        logger.debug(&#34;websocket: received pong&#34;)
                else:
                    logger.warning(&#34;websocket: unknown message type - {}&#34;.format(ws_message.type))
        except Exception as e:
            logger.exception(e)
        finally:
            if self.ping_task:
                self.ping_task.cancel()
                self.ping_task = None
                if self.log:
                    logger.debug(&#34;websocket: ping task complete&#34;)
    logger.info(&#34;websocket: disconnected&#34;)
    self.mirai_session.session_key = None
    await self.session.close()</code></pre>
</details>
</dd>
<dt id="ariadne.adapter.CombinedAdapter.raw_data_parser"><code class="name flex">
<span>async def <span class="ident">raw_data_parser</span></span>(<span>self, raw_data: dict) ‑> Optional[graia.broadcast.entities.event.Dispatchable]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def raw_data_parser(self, raw_data: dict) -&gt; Optional[Dispatchable]:
    received_data = raw_data[&#34;data&#34;]
    validate_response(received_data)
    if session_key := received_data.get(&#34;session&#34;, None):
        self.mirai_session.session_key = session_key
        return
    event = await self.build_event(received_data)
    return event</code></pre>
</details>
</dd>
<dt id="ariadne.adapter.CombinedAdapter.ws_ping"><code class="name flex">
<span>async def <span class="ident">ws_ping</span></span>(<span>self, interval: float = 30.0) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def ws_ping(self, interval: float = 30.0) -&gt; None:
    while self.running:
        try:
            try:
                await self.ws_conn.ping()
                if self.log:
                    logger.debug(&#34;websocket: ping&#34;)
            except Exception as e:
                logger.exception(f&#34;websocket: ping failed: {e!r}&#34;)
            else:
                if self.log:
                    logger.debug(f&#34;websocket: ping success, delay {interval}s&#34;)
                await asyncio.sleep(interval)
        except asyncio.CancelledError:
            if self.log:
                logger.debug(&#34;websocket: pinger exit&#34;)
            break</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ariadne.adapter.CombinedAdapter"><code class="flex name class">
<span>class <span class="ident">DefaultAdapter</span></span>
<span>(</span><span>broadcast: graia.broadcast.Broadcast, mirai_session: <a title="ariadne.model.MiraiSession" href="model.html#ariadne.model.MiraiSession">MiraiSession</a>, ping: bool = True, log: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>使用正向Websocket接收事件与消息, 用HTTP发送消息/操作的适配器.
稳定与性能的平衡, 但需要 Mirai API HTTP 同时启用 <code>http</code> 与 <code>ws</code> 适配器.</p>
<h2 id="args">Args</h2>
<dl>
<dt>bcc(Broadcast): Broadcast 实例</dt>
<dt><strong><code>session</code></strong></dt>
<dd>Session 实例, 存储了连接信息</dd>
</dl>
<p>ping(bool): 是否启用 ping 功能.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CombinedAdapter(Adapter):
    &#34;&#34;&#34;
    使用正向Websocket接收事件与消息, 用HTTP发送消息/操作的适配器.
    稳定与性能的平衡, 但需要 Mirai API HTTP 同时启用 `http` 与 `ws` 适配器.

    Args:
        bcc(Broadcast): Broadcast 实例
        session: Session 实例, 存储了连接信息
        ping(bool): 是否启用 ping 功能.
    &#34;&#34;&#34;

    def __init__(
        self, broadcast: Broadcast, mirai_session: MiraiSession, ping: bool = True, log: bool = True
    ) -&gt; None:
        super().__init__(broadcast, mirai_session, log)
        self.ping = ping
        self.ping_task: Optional[Task] = None
        self.ws_conn: Optional[ClientWebSocketResponse] = None
        self.query_dict = {&#34;verifyKey&#34;: mirai_session.verify_key}
        if not mirai_session.single_mode:
            self.query_dict[&#34;qq&#34;] = mirai_session.account

    ws_ping = WebsocketAdapter.ws_ping

    call_api = HttpAdapter.call_api

    async def raw_data_parser(self, raw_data: dict) -&gt; Optional[Dispatchable]:
        received_data = raw_data[&#34;data&#34;]
        validate_response(received_data)
        if session_key := received_data.get(&#34;session&#34;, None):
            self.mirai_session.session_key = session_key
            return
        event = await self.build_event(received_data)
        return event

    fetch_cycle = WebsocketAdapter.fetch_cycle</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ariadne.adapter.Adapter" href="#ariadne.adapter.Adapter">Adapter</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ariadne.adapter.DebugAdapter" href="#ariadne.adapter.DebugAdapter">DebugAdapter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ariadne.adapter.CombinedAdapter.raw_data_parser"><code class="name flex">
<span>async def <span class="ident">raw_data_parser</span></span>(<span>self, raw_data: dict) ‑> Optional[graia.broadcast.entities.event.Dispatchable]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def raw_data_parser(self, raw_data: dict) -&gt; Optional[Dispatchable]:
    received_data = raw_data[&#34;data&#34;]
    validate_response(received_data)
    if session_key := received_data.get(&#34;session&#34;, None):
        self.mirai_session.session_key = session_key
        return
    event = await self.build_event(received_data)
    return event</code></pre>
</details>
</dd>
<dt id="ariadne.adapter.CombinedAdapter.ws_ping"><code class="name flex">
<span>async def <span class="ident">ws_ping</span></span>(<span>self, interval: float = 30.0) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def ws_ping(self, interval: float = 30.0) -&gt; None:
    while self.running:
        try:
            try:
                await self.ws_conn.ping()
                if self.log:
                    logger.debug(&#34;websocket: ping&#34;)
            except Exception as e:
                logger.exception(f&#34;websocket: ping failed: {e!r}&#34;)
            else:
                if self.log:
                    logger.debug(f&#34;websocket: ping success, delay {interval}s&#34;)
                await asyncio.sleep(interval)
        except asyncio.CancelledError:
            if self.log:
                logger.debug(&#34;websocket: pinger exit&#34;)
            break</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ariadne.adapter.Adapter" href="#ariadne.adapter.Adapter">Adapter</a></b></code>:
<ul class="hlist">
<li><code><a title="ariadne.adapter.Adapter.build_event" href="#ariadne.adapter.Adapter.build_event">build_event</a></code></li>
<li><code><a title="ariadne.adapter.Adapter.call_api" href="#ariadne.adapter.Adapter.call_api">call_api</a></code></li>
<li><code><a title="ariadne.adapter.Adapter.fetch_cycle" href="#ariadne.adapter.Adapter.fetch_cycle">fetch_cycle</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ariadne.adapter.DebugAdapter"><code class="flex name class">
<span>class <span class="ident">DebugAdapter</span></span>
<span>(</span><span>broadcast: graia.broadcast.Broadcast, mirai_session: <a title="ariadne.model.MiraiSession" href="model.html#ariadne.model.MiraiSession">MiraiSession</a>, ping: bool = True, log: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Debugging adapter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DebugAdapter(DefaultAdapter):
    &#34;&#34;&#34;
    Debugging adapter
    &#34;&#34;&#34;

    async def build_event(self, data: dict) -&gt; MiraiEvent:
        &#34;&#34;&#34;
        从尚未明确指定事件类型的对象中获取事件的定义, 并进行解析

        Args:
            data (dict): 用 dict 表示的序列化态事件, 应包含有字段 `type` 以供分析事件定义.

        Raises:
            InvalidArgument: 目标对象中不包含字段 `type`
            ValueError: 没有找到对应的字段, 通常的, 这意味着应用获取到了一个尚未被定义的事件, 请报告问题.

        Returns:
            MiraiEvent: 已经被序列化的事件
        &#34;&#34;&#34;
        try:
            event = await super().build_event(data)
        except ValueError as e:
            logger.error(f&#34;{e.args[0]}\n{json.dumps(data, indent=4)}&#34;)
            raise
        else:
            logger.debug(event)
            return event</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ariadne.adapter.CombinedAdapter" href="#ariadne.adapter.CombinedAdapter">CombinedAdapter</a></li>
<li><a title="ariadne.adapter.Adapter" href="#ariadne.adapter.Adapter">Adapter</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ariadne.adapter.CombinedAdapter" href="#ariadne.adapter.CombinedAdapter">CombinedAdapter</a></b></code>:
<ul class="hlist">
<li><code><a title="ariadne.adapter.CombinedAdapter.build_event" href="#ariadne.adapter.Adapter.build_event">build_event</a></code></li>
<li><code><a title="ariadne.adapter.CombinedAdapter.fetch_cycle" href="#ariadne.adapter.Adapter.fetch_cycle">fetch_cycle</a></code></li>
</ul>
</li>
<li><code><b><a title="ariadne.adapter.Adapter" href="#ariadne.adapter.Adapter">Adapter</a></b></code>:
<ul class="hlist">
<li><code><a title="ariadne.adapter.Adapter.call_api" href="#ariadne.adapter.Adapter.call_api">call_api</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ariadne.adapter.HttpAdapter"><code class="flex name class">
<span>class <span class="ident">HttpAdapter</span></span>
<span>(</span><span>broadcast: graia.broadcast.Broadcast, mirai_session: <a title="ariadne.model.MiraiSession" href="model.html#ariadne.model.MiraiSession">MiraiSession</a>, fetch_interval: float = 0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>仅使用正向 HTTP 的适配器, 采用短轮询接收事件/消息.
不推荐.
Note: Working In Progress</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpAdapter(Adapter):
    &#34;&#34;&#34;
    仅使用正向 HTTP 的适配器, 采用短轮询接收事件/消息.
    不推荐.
    Note: Working In Progress
    &#34;&#34;&#34;

    def __init__(
        self,
        broadcast: Broadcast,
        mirai_session: MiraiSession,
        fetch_interval: float = 0.5,
    ) -&gt; None:
        super().__init__(broadcast, mirai_session)
        self.fetch_interval = fetch_interval
        raise NotImplementedError(&#34;HTTP Adapter is not supported yet!&#34;)

    async def fetch_cycle(self) -&gt; None:
        self.running = True
        self.session = ClientSession()
        if not self.queue:
            self.queue = Queue()
        while self.running:
            await asyncio.sleep(self.fetch_interval)
        self.mirai_session.session_key = None
        await self.session.close()

    @require_verified
    @error_wrapper
    async def call_api(
        self,
        action: str,
        method: CallMethod,
        data: Optional[Union[Dict[str, Any], str]] = None,
    ) -&gt; Union[dict, list]:
        if not data:
            data = dict()
        if not self.session:
            raise RuntimeError(&#34;Unable to get session!&#34;)

        if method == CallMethod.GET or method == CallMethod.RESTGET:
            if isinstance(data, str):
                data = json.loads(data)
            async with self.session.get(URL(self.mirai_session.url_gen(action)).with_query(data)) as response:
                response.raise_for_status()
                resp_json: dict = await response.json()

        elif method == CallMethod.POST or method == CallMethod.RESTPOST:
            if not isinstance(data, str):
                data = json.dumps(data, cls=DatetimeEncoder)
            async with self.session.post(self.mirai_session.url_gen(action), data=data) as response:
                response.raise_for_status()
                resp_json: dict = await response.json()

        else:  # MULTIPART
            form = FormData()
            if not isinstance(data, dict):
                raise ValueError(&#34;Data must be a dict in multipart call!&#34;)
            for k, v in data.items():
                form.add_fields(k, v)
            async with self.session.post(self.mirai_session.url_gen(action), data=form) as response:
                response.raise_for_status()
                resp_json: dict = await response.json()
        if &#34;data&#34; in resp_json:
            resp = resp_json[&#34;data&#34;]
        else:
            resp = resp_json

        validate_response(resp)
        return resp</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ariadne.adapter.Adapter" href="#ariadne.adapter.Adapter">Adapter</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ariadne.adapter.Adapter" href="#ariadne.adapter.Adapter">Adapter</a></b></code>:
<ul class="hlist">
<li><code><a title="ariadne.adapter.Adapter.build_event" href="#ariadne.adapter.Adapter.build_event">build_event</a></code></li>
<li><code><a title="ariadne.adapter.Adapter.call_api" href="#ariadne.adapter.Adapter.call_api">call_api</a></code></li>
<li><code><a title="ariadne.adapter.Adapter.fetch_cycle" href="#ariadne.adapter.Adapter.fetch_cycle">fetch_cycle</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ariadne.adapter.WebsocketAdapter"><code class="flex name class">
<span>class <span class="ident">WebsocketAdapter</span></span>
<span>(</span><span>broadcast: graia.broadcast.Broadcast, mirai_session: <a title="ariadne.model.MiraiSession" href="model.html#ariadne.model.MiraiSession">MiraiSession</a>, ping: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>仅使用正向 Websocket 的适配器.
因 Mirai API HTTP 的实现, 部分功能不可用.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WebsocketAdapter(Adapter):
    &#34;&#34;&#34;
    仅使用正向 Websocket 的适配器.
    因 Mirai API HTTP 的实现, 部分功能不可用.
    &#34;&#34;&#34;

    class SyncIdManager:
        allocated: Set[int] = {0}

        @classmethod
        def allocate(cls) -&gt; int:
            new_id = max(cls.allocated) + 1
            cls.allocated.add(new_id)
            return new_id

        @classmethod
        def done(cls, sync_id: int) -&gt; None:
            if sync_id in cls.allocated:
                cls.allocated.remove(sync_id)

    class CallResponse(Event):
        def __init__(self, *, loop: AbstractEventLoop = None) -&gt; None:
            super().__init__(loop=loop)
            self.response: Optional[dict] = None

    def __init__(self, broadcast: Broadcast, mirai_session: MiraiSession, ping: bool = True) -&gt; None:
        super().__init__(broadcast, mirai_session)
        self.ping = ping
        self.ping_task: Optional[Task] = None
        self.ws_conn: Optional[ClientWebSocketResponse] = None
        self.query_dict = {&#34;verifyKey&#34;: mirai_session.verify_key}
        self.sync_event: Dict[int, WebsocketAdapter.CallResponse] = {}
        if not mirai_session.single_mode:
            self.query_dict[&#34;qq&#34;] = mirai_session.account

    async def ws_ping(self, interval: float = 30.0) -&gt; None:
        while self.running:
            try:
                try:
                    await self.ws_conn.ping()
                    if self.log:
                        logger.debug(&#34;websocket: ping&#34;)
                except Exception as e:
                    logger.exception(f&#34;websocket: ping failed: {e!r}&#34;)
                else:
                    if self.log:
                        logger.debug(f&#34;websocket: ping success, delay {interval}s&#34;)
                    await asyncio.sleep(interval)
            except asyncio.CancelledError:
                if self.log:
                    logger.debug(&#34;websocket: pinger exit&#34;)
                break

    @require_verified
    @error_wrapper
    async def call_api(
        self, action: str, method: CallMethod, data: Optional[Union[dict, str]] = None
    ) -&gt; Union[dict, list]:
        data = data or dict()
        if not self.ws_conn:
            raise ValueError(&#34;no existing websocket connection&#34;)
        sync_id = self.SyncIdManager.allocate()
        event = self.CallResponse()
        self.sync_event[sync_id] = event
        content = {
            &#34;syncId&#34;: sync_id,
            &#34;command&#34;: action,
            &#34;content&#34;: data,
        }
        if method == CallMethod.RESTGET:
            content[&#34;subCommand&#34;] = &#34;get&#34;
        elif method == CallMethod.RESTPOST:
            content[&#34;subCommand&#34;] = &#34;update&#34;
        elif method == CallMethod.MULTIPART:
            raise NotImplementedError(f&#34;Unsupported operation for WebsocketAdapter: {method}&#34;)

        await self.ws_conn.send_str(json.dumps(content, cls=DatetimeEncoder))
        logger.debug(f&#34;websocket：sent with sync id: {sync_id}&#34;)
        await event.wait()
        self.SyncIdManager.done(sync_id)
        value: dict = event.response
        del self.sync_event[sync_id]
        del event
        validate_response(value)
        if &#34;data&#34; in value:
            return value[&#34;data&#34;]
        return value

    async def raw_data_parser(self, raw_data: dict) -&gt; Optional[Dispatchable]:
        sync_id: str = raw_data[&#34;syncId&#34;]
        received_data: dict = raw_data[&#34;data&#34;]
        validate_response(received_data)
        if not self.mirai_session.session_key:
            if session_key := received_data.get(&#34;session&#34;, None):
                self.mirai_session.session_key = session_key
            return
        sync_id = int(sync_id)
        if sync_id not in self.SyncIdManager.allocated:
            event = await self.build_event(received_data)
            return event
        else:
            if sync_id in self.sync_event:
                response = self.sync_event[sync_id]
                response.response = received_data
                response.set()

    async def fetch_cycle(self) -&gt; None:
        self.session = ClientSession()
        self.running = True
        if not self.queue:
            self.queue = Queue()
        async with self.session.ws_connect(
            str(URL(self.mirai_session.url_gen(&#34;all&#34;)).with_query(self.query_dict)),
            autoping=False,
        ) as connection:
            logger.info(&#34;websocket: connected&#34;)
            self.ws_conn = connection

            if self.ping:
                self.ping_task = self.loop.create_task(self.ws_ping(), name=&#34;ariadne_adapter_ws_ping&#34;)
                logger.info(&#34;websocket: ping task created&#34;)
            try:
                async for ws_message in yield_with_timeout(connection.receive, lambda: self.running):
                    if ws_message.type is WSMsgType.TEXT:
                        original_data: dict = json.loads(ws_message.data)
                        event = await self.raw_data_parser(original_data)
                        if event:
                            await self.queue.put(event)
                    elif ws_message.type is WSMsgType.CLOSED:
                        logger.warning(&#34;websocket: connection has been closed.&#34;)
                        return
                    elif ws_message.type is WSMsgType.PONG:
                        if self.log:
                            logger.debug(&#34;websocket: received pong&#34;)
                    else:
                        logger.warning(&#34;websocket: unknown message type - {}&#34;.format(ws_message.type))
            except Exception as e:
                logger.exception(e)
            finally:
                if self.ping_task:
                    self.ping_task.cancel()
                    self.ping_task = None
                    if self.log:
                        logger.debug(&#34;websocket: ping task complete&#34;)
        logger.info(&#34;websocket: disconnected&#34;)
        self.mirai_session.session_key = None
        await self.session.close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ariadne.adapter.Adapter" href="#ariadne.adapter.Adapter">Adapter</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ariadne.adapter.WebsocketAdapter.CallResponse"><code class="name">var <span class="ident">CallResponse</span></code></dt>
<dd>
<div class="desc"><p>Asynchronous equivalent to threading.Event.</p>
<p>Class implementing event objects. An event manages a flag that can be set
to true with the set() method and reset to false with the clear() method.
The wait() method blocks until the flag is true. The flag is initially
false.</p></div>
</dd>
<dt id="ariadne.adapter.WebsocketAdapter.SyncIdManager"><code class="name">var <span class="ident">SyncIdManager</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ariadne.adapter.WebsocketAdapter.raw_data_parser"><code class="name flex">
<span>async def <span class="ident">raw_data_parser</span></span>(<span>self, raw_data: dict) ‑> Optional[graia.broadcast.entities.event.Dispatchable]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def raw_data_parser(self, raw_data: dict) -&gt; Optional[Dispatchable]:
    sync_id: str = raw_data[&#34;syncId&#34;]
    received_data: dict = raw_data[&#34;data&#34;]
    validate_response(received_data)
    if not self.mirai_session.session_key:
        if session_key := received_data.get(&#34;session&#34;, None):
            self.mirai_session.session_key = session_key
        return
    sync_id = int(sync_id)
    if sync_id not in self.SyncIdManager.allocated:
        event = await self.build_event(received_data)
        return event
    else:
        if sync_id in self.sync_event:
            response = self.sync_event[sync_id]
            response.response = received_data
            response.set()</code></pre>
</details>
</dd>
<dt id="ariadne.adapter.WebsocketAdapter.ws_ping"><code class="name flex">
<span>async def <span class="ident">ws_ping</span></span>(<span>self, interval: float = 30.0) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def ws_ping(self, interval: float = 30.0) -&gt; None:
    while self.running:
        try:
            try:
                await self.ws_conn.ping()
                if self.log:
                    logger.debug(&#34;websocket: ping&#34;)
            except Exception as e:
                logger.exception(f&#34;websocket: ping failed: {e!r}&#34;)
            else:
                if self.log:
                    logger.debug(f&#34;websocket: ping success, delay {interval}s&#34;)
                await asyncio.sleep(interval)
        except asyncio.CancelledError:
            if self.log:
                logger.debug(&#34;websocket: pinger exit&#34;)
            break</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ariadne.adapter.Adapter" href="#ariadne.adapter.Adapter">Adapter</a></b></code>:
<ul class="hlist">
<li><code><a title="ariadne.adapter.Adapter.build_event" href="#ariadne.adapter.Adapter.build_event">build_event</a></code></li>
<li><code><a title="ariadne.adapter.Adapter.call_api" href="#ariadne.adapter.Adapter.call_api">call_api</a></code></li>
<li><code><a title="ariadne.adapter.Adapter.fetch_cycle" href="#ariadne.adapter.Adapter.fetch_cycle">fetch_cycle</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ariadne" href="index.html">ariadne</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ariadne.adapter.error_wrapper" href="#ariadne.adapter.error_wrapper">error_wrapper</a></code></li>
<li><code><a title="ariadne.adapter.require_verified" href="#ariadne.adapter.require_verified">require_verified</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ariadne.adapter.Adapter" href="#ariadne.adapter.Adapter">Adapter</a></code></h4>
<ul class="two-column">
<li><code><a title="ariadne.adapter.Adapter.build_event" href="#ariadne.adapter.Adapter.build_event">build_event</a></code></li>
<li><code><a title="ariadne.adapter.Adapter.call_api" href="#ariadne.adapter.Adapter.call_api">call_api</a></code></li>
<li><code><a title="ariadne.adapter.Adapter.fetch_cycle" href="#ariadne.adapter.Adapter.fetch_cycle">fetch_cycle</a></code></li>
<li><code><a title="ariadne.adapter.Adapter.session_activated" href="#ariadne.adapter.Adapter.session_activated">session_activated</a></code></li>
<li><code><a title="ariadne.adapter.Adapter.start" href="#ariadne.adapter.Adapter.start">start</a></code></li>
<li><code><a title="ariadne.adapter.Adapter.stop" href="#ariadne.adapter.Adapter.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ariadne.adapter.CombinedAdapter" href="#ariadne.adapter.CombinedAdapter">CombinedAdapter</a></code></h4>
<ul class="">
<li><code><a title="ariadne.adapter.CombinedAdapter.call_api" href="#ariadne.adapter.CombinedAdapter.call_api">call_api</a></code></li>
<li><code><a title="ariadne.adapter.CombinedAdapter.fetch_cycle" href="#ariadne.adapter.CombinedAdapter.fetch_cycle">fetch_cycle</a></code></li>
<li><code><a title="ariadne.adapter.CombinedAdapter.raw_data_parser" href="#ariadne.adapter.CombinedAdapter.raw_data_parser">raw_data_parser</a></code></li>
<li><code><a title="ariadne.adapter.CombinedAdapter.ws_ping" href="#ariadne.adapter.CombinedAdapter.ws_ping">ws_ping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ariadne.adapter.CombinedAdapter" href="#ariadne.adapter.CombinedAdapter">CombinedAdapter</a></code></h4>
<ul class="">
<li><code><a title="ariadne.adapter.CombinedAdapter.raw_data_parser" href="#ariadne.adapter.CombinedAdapter.raw_data_parser">raw_data_parser</a></code></li>
<li><code><a title="ariadne.adapter.CombinedAdapter.ws_ping" href="#ariadne.adapter.CombinedAdapter.ws_ping">ws_ping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ariadne.adapter.DebugAdapter" href="#ariadne.adapter.DebugAdapter">DebugAdapter</a></code></h4>
</li>
<li>
<h4><code><a title="ariadne.adapter.HttpAdapter" href="#ariadne.adapter.HttpAdapter">HttpAdapter</a></code></h4>
</li>
<li>
<h4><code><a title="ariadne.adapter.WebsocketAdapter" href="#ariadne.adapter.WebsocketAdapter">WebsocketAdapter</a></code></h4>
<ul class="">
<li><code><a title="ariadne.adapter.WebsocketAdapter.CallResponse" href="#ariadne.adapter.WebsocketAdapter.CallResponse">CallResponse</a></code></li>
<li><code><a title="ariadne.adapter.WebsocketAdapter.SyncIdManager" href="#ariadne.adapter.WebsocketAdapter.SyncIdManager">SyncIdManager</a></code></li>
<li><code><a title="ariadne.adapter.WebsocketAdapter.raw_data_parser" href="#ariadne.adapter.WebsocketAdapter.raw_data_parser">raw_data_parser</a></code></li>
<li><code><a title="ariadne.adapter.WebsocketAdapter.ws_ping" href="#ariadne.adapter.WebsocketAdapter.ws_ping">ws_ping</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>