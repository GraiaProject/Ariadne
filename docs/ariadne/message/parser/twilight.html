<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ariadne.message.parser.twilight API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ariadne.message.parser.twilight</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import re
import string
from copy import deepcopy
from typing import (
    Dict,
    Generic,
    Iterable,
    List,
    Optional,
    Tuple,
    Type,
    TypedDict,
    TypeVar,
    Union,
    overload,
)

from graia.broadcast.entities.dispatcher import BaseDispatcher
from graia.broadcast.exceptions import ExecutionStop
from graia.broadcast.interfaces.dispatcher import DispatcherInterface
from pydantic.utils import Representation

from ...event.message import MessageEvent
from ..chain import MessageChain
from ..element import Element
from .pattern import ArgumentMatch, ElementMatch, Match, RegexMatch
from .util import ElementType, MessageChainType, TwilightParser, elem_mapping_ctx, split


class Sparkle(Representation):
    __dict__: Dict[str, Match]

    _description: str = &#34;&#34;
    _epilog: str = &#34;&#34;

    def __repr_args__(self):
        check = [(None, [item[0] for item in self._list_check_match])]
        return check + [(k, v) for k, v in self.__dict__.items() if isinstance(v, Match)]

    def __getitem__(self, item: Union[str, int]) -&gt; Match:
        if isinstance(item, str):
            return getattr(self, item)
        if isinstance(item, int):
            return self._list_check_match[item][0]

    def __init_subclass__(cls, /, *, description: str = &#34;&#34;, epilog: str = &#34;&#34;, **kwargs) -&gt; None:
        super().__init_subclass__(**kwargs)
        cls._description = description
        cls._epilog = epilog

    @overload
    def __init__(self, check: Dict[str, Match]):
        ...

    @overload
    def __init__(
        self,
        check: Iterable[RegexMatch] = (),
        match: Optional[Dict[str, Match]] = None,
    ):
        ...

    def __init__(
        self,
        check: Iterable[RegexMatch] = (),
        match: Optional[Dict[str, Match]] = None,
        description: str = &#34;&#34;,
        epilog: str = &#34;&#34;,
    ):
        self._description = description or self._description
        self._epilog = epilog or self._epilog

        if isinstance(check, dict):
            match, check = check, match  # swap
            check: Iterable[RegexMatch]
            match: Dict[str, Match]

        if check is ... or not check:
            check = ()
        if match is ... or not match:
            match = {}

        match_map = {k: v for k, v in self.__class__.__dict__.items() if isinstance(v, Match)}
        match_map.update(match)

        # ----
        # ordinary matches
        # ----

        group_cnt: int = 0
        match_pattern_list: List[str] = []

        self._list_regex_match: List[Tuple[RegexMatch, int, str]] = []
        self._mapping_arg_match: Dict[str, Tuple[ArgumentMatch, str]] = {}

        self._parser = TwilightParser(prog=&#34;&#34;, add_help=False)
        for k, v in match_map.items():
            if k.startswith(&#34;_&#34;) or k[0] in string.digits:
                raise ValueError(&#34;Invalid Match object name!&#34;)

            setattr(self, k, v)

            if isinstance(v, Match):
                if isinstance(v, ArgumentMatch):  # add to self._parser
                    self._mapping_arg_match[v.name] = (v, k)
                    if v.action is ... or self._parser.accept_type(v.action):
                        if &#34;type&#34; not in v.add_arg_data or v.add_arg_data[&#34;type&#34;] is MessageChain:
                            v.add_arg_data[&#34;type&#34;] = MessageChainType(v, v.regex)
                        elif isinstance(v.add_arg_data[&#34;type&#34;], type) and issubclass(
                            v.add_arg_data[&#34;type&#34;], Element
                        ):
                            v.add_arg_data[&#34;type&#34;] = ElementType(v, v.add_arg_data[&#34;type&#34;])
                    self._parser.add_argument(*v.pattern, **v.add_arg_data)

                elif isinstance(v, RegexMatch):  # add to self._list_regex_match
                    self._list_regex_match.append((v, group_cnt + 1, k))
                    group_cnt += re.compile(v.gen_regex()).groups
                    match_pattern_list.append(v.gen_regex())

                else:
                    raise ValueError(f&#34;{v} is neither RegexMatch nor ArgumentMatch!&#34;)

        if (
            not all(v[0].pattern[0].startswith(&#34;-&#34;) for v in self._mapping_arg_match.values())
            and self._list_regex_match
        ):  # inline validation for underscore
            raise ValueError(&#34;ArgumentMatch&#39;s pattern can&#39;t start with &#39;-&#39; in this case!&#34;)

        self._regex_pattern = &#34;&#34;.join(match_pattern_list)
        self._regex = re.compile(self._regex_pattern)

        # ----
        # checking matches
        # ----

        self._list_check_match: List[Tuple[Match, int]] = []

        group_cnt = 0

        for check_match in check:
            if not isinstance(check_match, RegexMatch):
                raise ValueError(f&#34;{check_match} can&#39;t be used as checking match!&#34;)
            self._list_check_match.append((check_match, group_cnt + 1))
            group_cnt += re.compile(check_match.gen_regex()).groups
        self._check_pattern: str = &#34;&#34;.join(check_match.gen_regex() for check_match in check)
        self._check_regex = re.compile(self._check_pattern)

    # ---
    # Runtime populate
    # ---

    def populate_check_match(self, string: str, elem_mapping: Dict[int, Element]) -&gt; List[str]:
        if not self._check_pattern:
            return split(string)
        if regex_match := self._check_regex.match(string):
            for match, index in self._list_check_match:
                current = regex_match.group(index) or &#34;&#34;
                if isinstance(match, ElementMatch):
                    if current:
                        index = re.fullmatch(&#34;\x02(\\d+)_\\w+\x03&#34;, current).group(1)
                        result = elem_mapping[int(index)]
                    else:
                        result = None
                else:
                    result = MessageChain.fromMappingString(current, elem_mapping)

                match.result = result
                match.matched = bool(current)

                if match.__class__ is RegexMatch:
                    match.regex_match = re.fullmatch(match.pattern, current)
            return split(string[regex_match.end() :])
        else:
            raise ValueError(f&#34;Not matching regex: {self._check_pattern}&#34;)

    def populate_arg_match(self, args: List[str]) -&gt; List[str]:
        if not self._mapping_arg_match:  # Optimization: skip if no ArgumentMatch
            return args
        namespace, rest = self._parser.parse_known_args(args)
        for arg_name, val_tuple in self._mapping_arg_match.items():
            match, sparkle_name = val_tuple
            namespace_val = getattr(namespace, arg_name, None)
            if arg_name in namespace.__dict__:
                match.result = namespace_val
                match.matched = bool(namespace_val)

            if getattr(self, sparkle_name, None) is None:
                setattr(self, sparkle_name, match)

        return rest

    def populate_regex_match(self, elem_mapping: Dict[str, Element], arg_list: List[str]) -&gt; None:
        if self._regex_pattern:
            if regex_match := self._regex.fullmatch(&#34; &#34;.join(arg_list)):
                for match, index, name in self._list_regex_match:
                    current = regex_match.group(index) or &#34;&#34;
                    if isinstance(match, ElementMatch):
                        if current:
                            index = re.fullmatch(&#34;\x02(\\d+)_\\w+\x03&#34;, current).group(1)
                            result = elem_mapping[int(index)]
                        else:
                            result = None
                    else:
                        result = MessageChain.fromMappingString(current, elem_mapping)

                    match.result = result
                    match.matched = bool(current)

                    if match.__class__ is RegexMatch:
                        match.regex_match = re.fullmatch(match.pattern, current)

                    if getattr(self, name, None) is None:
                        setattr(self, name, match)

            else:
                raise ValueError(f&#34;Regex not matching: {self._regex_pattern}&#34;)

    def get_help(self, description: str = &#34;&#34;, epilog: str = &#34;&#34;, *, header: bool = True) -&gt; str:

        formatter = self._parser._get_formatter()

        description = description or self._description
        formatter.add_text(description)

        if header:
            header: List[str] = [&#34;使用方法:&#34;]

            for match, *_ in self._list_check_match:
                header.append(match.get_help())

            for match, *_ in self._list_regex_match:
                header.append(match.get_help())

            formatter.add_usage(None, self._parser._actions, [], prefix=&#34; &#34;.join(header) + &#34; &#34;)

        positional, optional, *_ = self._parser._action_groups
        formatter.start_section(&#34;位置匹配&#34;)
        for match, _, name in self._list_regex_match:
            formatter.add_text(f&#34;{name} -&gt; 匹配 {match.get_help()}{&#39; : &#39; + match.help if match.help else &#39;&#39;}&#34;)
        formatter.add_arguments(positional._group_actions)
        formatter.end_section()

        formatter.start_section(&#34;参数匹配&#34;)
        formatter.add_arguments(optional._group_actions)
        formatter.end_section()

        epilog = epilog or self._epilog
        formatter.add_text(epilog)

        # determine help from format above
        return formatter.format_help()


T_Sparkle = TypeVar(&#34;T_Sparkle&#34;, bound=Sparkle)


class _TwilightLocalStorage(TypedDict):
    result: Optional[Sparkle]


class Twilight(BaseDispatcher, Generic[T_Sparkle]):
    &#34;&#34;&#34;
    暮光.
    &#34;&#34;&#34;

    @overload
    def __init__(self, root: Dict[str, Match], *, map_params: Optional[Dict[str, bool]] = None):
        &#34;&#34;&#34;本魔法方法用于初始化本实例.

        Args:
            check (Dict[str, Match]): 匹配的映射.
            map_params (Dict[str, bool], optional): 向 MessageChain.asMappingString 传入的参数.
        &#34;&#34;&#34;

    @overload
    def __init__(
        self, root: Union[Type[T_Sparkle], T_Sparkle], *, map_params: Optional[Dict[str, bool]] = None
    ):
        &#34;&#34;&#34;本魔法方法用于初始化本实例.

        Args:
            root (Union[Type[Twilight], Twilight], optional): 根 Sparkle 实例, 用于生成新的 Sparkle.
            map_params (Dict[str, bool], optional): 向 MessageChain.asMappingString 传入的参数.
        &#34;&#34;&#34;

    @overload
    def __init__(
        self,
        root: Iterable[RegexMatch],
        match: Dict[str, Match] = ...,
        *,
        map_params: Optional[Dict[str, bool]] = None,
    ):
        &#34;&#34;&#34;本魔法方法用于初始化本实例.

        Args:
            check (Iterable[RegexMatch]): 用于检查的 Match 对象.
            match (Dict[str, Match]): 额外匹配的映射.
            map_params (Dict[str, bool], optional): 向 MessageChain.asMappingString 传入的参数.
        &#34;&#34;&#34;

    def __init__(self, root=..., match=..., *, map_params: Optional[Dict[str, bool]] = None):
        &#34;Actual implementation of __init__&#34;
        if isinstance(root, Sparkle):
            self.root = root
        elif isinstance(root, type) and issubclass(root, Sparkle):
            self.root = root()
        else:
            self.root = Sparkle(check=root, match=match)

        self._map_params = map_params or {}

    def generate(self, chain: MessageChain) -&gt; T_Sparkle:
        sparkle = deepcopy(self.root)
        mapping_str, elem_mapping = chain.asMappingString(**self._map_params)
        token = elem_mapping_ctx.set(chain)
        try:
            str_list = sparkle.populate_check_match(mapping_str, elem_mapping)
            arg_list = sparkle.populate_arg_match(str_list)
            sparkle.populate_regex_match(elem_mapping, arg_list)
        except Exception:
            raise
        elem_mapping_ctx.reset(token)
        return sparkle

    def beforeExecution(self, interface: &#34;DispatcherInterface[MessageEvent]&#34;):
        if not isinstance(interface.event, MessageEvent):
            raise ExecutionStop
        local_storage: _TwilightLocalStorage = interface.execution_contexts[-1].local_storage
        chain: MessageChain = interface.event.messageChain
        try:
            local_storage[&#34;result&#34;] = self.generate(chain)
        except:
            raise ExecutionStop

    async def catch(
        self, interface: &#34;DispatcherInterface[MessageEvent]&#34;
    ) -&gt; Optional[Union[&#34;Twilight&#34;, T_Sparkle, Match]]:
        local_storage: _TwilightLocalStorage = interface.execution_contexts[-1].local_storage
        sparkle = local_storage[&#34;result&#34;]
        if issubclass(interface.annotation, Sparkle):
            return sparkle
        if issubclass(interface.annotation, Twilight):
            return self
        if issubclass(interface.annotation, Match):
            if hasattr(sparkle, interface.name):
                match: Match = getattr(sparkle, interface.name)
                if isinstance(match, interface.annotation):
                    return match</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ariadne.message.parser.twilight.Sparkle"><code class="flex name class">
<span>class <span class="ident">Sparkle</span></span>
<span>(</span><span>check: Iterable[<a title="ariadne.message.parser.pattern.RegexMatch" href="pattern.html#ariadne.message.parser.pattern.RegexMatch">RegexMatch</a>] = (), match: Optional[Dict[str, <a title="ariadne.message.parser.pattern.Match" href="pattern.html#ariadne.message.parser.pattern.Match">Match</a>]] = None, description: str = '', epilog: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Mixin to provide <strong>str</strong>, <strong>repr</strong>, and <strong>pretty</strong> methods. See #884 for more details.</p>
<p><strong>pretty</strong> is used by <a href="https://python-devtools.helpmanual.io/">devtools</a> to provide human readable representations
of objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sparkle(Representation):
    __dict__: Dict[str, Match]

    _description: str = &#34;&#34;
    _epilog: str = &#34;&#34;

    def __repr_args__(self):
        check = [(None, [item[0] for item in self._list_check_match])]
        return check + [(k, v) for k, v in self.__dict__.items() if isinstance(v, Match)]

    def __getitem__(self, item: Union[str, int]) -&gt; Match:
        if isinstance(item, str):
            return getattr(self, item)
        if isinstance(item, int):
            return self._list_check_match[item][0]

    def __init_subclass__(cls, /, *, description: str = &#34;&#34;, epilog: str = &#34;&#34;, **kwargs) -&gt; None:
        super().__init_subclass__(**kwargs)
        cls._description = description
        cls._epilog = epilog

    @overload
    def __init__(self, check: Dict[str, Match]):
        ...

    @overload
    def __init__(
        self,
        check: Iterable[RegexMatch] = (),
        match: Optional[Dict[str, Match]] = None,
    ):
        ...

    def __init__(
        self,
        check: Iterable[RegexMatch] = (),
        match: Optional[Dict[str, Match]] = None,
        description: str = &#34;&#34;,
        epilog: str = &#34;&#34;,
    ):
        self._description = description or self._description
        self._epilog = epilog or self._epilog

        if isinstance(check, dict):
            match, check = check, match  # swap
            check: Iterable[RegexMatch]
            match: Dict[str, Match]

        if check is ... or not check:
            check = ()
        if match is ... or not match:
            match = {}

        match_map = {k: v for k, v in self.__class__.__dict__.items() if isinstance(v, Match)}
        match_map.update(match)

        # ----
        # ordinary matches
        # ----

        group_cnt: int = 0
        match_pattern_list: List[str] = []

        self._list_regex_match: List[Tuple[RegexMatch, int, str]] = []
        self._mapping_arg_match: Dict[str, Tuple[ArgumentMatch, str]] = {}

        self._parser = TwilightParser(prog=&#34;&#34;, add_help=False)
        for k, v in match_map.items():
            if k.startswith(&#34;_&#34;) or k[0] in string.digits:
                raise ValueError(&#34;Invalid Match object name!&#34;)

            setattr(self, k, v)

            if isinstance(v, Match):
                if isinstance(v, ArgumentMatch):  # add to self._parser
                    self._mapping_arg_match[v.name] = (v, k)
                    if v.action is ... or self._parser.accept_type(v.action):
                        if &#34;type&#34; not in v.add_arg_data or v.add_arg_data[&#34;type&#34;] is MessageChain:
                            v.add_arg_data[&#34;type&#34;] = MessageChainType(v, v.regex)
                        elif isinstance(v.add_arg_data[&#34;type&#34;], type) and issubclass(
                            v.add_arg_data[&#34;type&#34;], Element
                        ):
                            v.add_arg_data[&#34;type&#34;] = ElementType(v, v.add_arg_data[&#34;type&#34;])
                    self._parser.add_argument(*v.pattern, **v.add_arg_data)

                elif isinstance(v, RegexMatch):  # add to self._list_regex_match
                    self._list_regex_match.append((v, group_cnt + 1, k))
                    group_cnt += re.compile(v.gen_regex()).groups
                    match_pattern_list.append(v.gen_regex())

                else:
                    raise ValueError(f&#34;{v} is neither RegexMatch nor ArgumentMatch!&#34;)

        if (
            not all(v[0].pattern[0].startswith(&#34;-&#34;) for v in self._mapping_arg_match.values())
            and self._list_regex_match
        ):  # inline validation for underscore
            raise ValueError(&#34;ArgumentMatch&#39;s pattern can&#39;t start with &#39;-&#39; in this case!&#34;)

        self._regex_pattern = &#34;&#34;.join(match_pattern_list)
        self._regex = re.compile(self._regex_pattern)

        # ----
        # checking matches
        # ----

        self._list_check_match: List[Tuple[Match, int]] = []

        group_cnt = 0

        for check_match in check:
            if not isinstance(check_match, RegexMatch):
                raise ValueError(f&#34;{check_match} can&#39;t be used as checking match!&#34;)
            self._list_check_match.append((check_match, group_cnt + 1))
            group_cnt += re.compile(check_match.gen_regex()).groups
        self._check_pattern: str = &#34;&#34;.join(check_match.gen_regex() for check_match in check)
        self._check_regex = re.compile(self._check_pattern)

    # ---
    # Runtime populate
    # ---

    def populate_check_match(self, string: str, elem_mapping: Dict[int, Element]) -&gt; List[str]:
        if not self._check_pattern:
            return split(string)
        if regex_match := self._check_regex.match(string):
            for match, index in self._list_check_match:
                current = regex_match.group(index) or &#34;&#34;
                if isinstance(match, ElementMatch):
                    if current:
                        index = re.fullmatch(&#34;\x02(\\d+)_\\w+\x03&#34;, current).group(1)
                        result = elem_mapping[int(index)]
                    else:
                        result = None
                else:
                    result = MessageChain.fromMappingString(current, elem_mapping)

                match.result = result
                match.matched = bool(current)

                if match.__class__ is RegexMatch:
                    match.regex_match = re.fullmatch(match.pattern, current)
            return split(string[regex_match.end() :])
        else:
            raise ValueError(f&#34;Not matching regex: {self._check_pattern}&#34;)

    def populate_arg_match(self, args: List[str]) -&gt; List[str]:
        if not self._mapping_arg_match:  # Optimization: skip if no ArgumentMatch
            return args
        namespace, rest = self._parser.parse_known_args(args)
        for arg_name, val_tuple in self._mapping_arg_match.items():
            match, sparkle_name = val_tuple
            namespace_val = getattr(namespace, arg_name, None)
            if arg_name in namespace.__dict__:
                match.result = namespace_val
                match.matched = bool(namespace_val)

            if getattr(self, sparkle_name, None) is None:
                setattr(self, sparkle_name, match)

        return rest

    def populate_regex_match(self, elem_mapping: Dict[str, Element], arg_list: List[str]) -&gt; None:
        if self._regex_pattern:
            if regex_match := self._regex.fullmatch(&#34; &#34;.join(arg_list)):
                for match, index, name in self._list_regex_match:
                    current = regex_match.group(index) or &#34;&#34;
                    if isinstance(match, ElementMatch):
                        if current:
                            index = re.fullmatch(&#34;\x02(\\d+)_\\w+\x03&#34;, current).group(1)
                            result = elem_mapping[int(index)]
                        else:
                            result = None
                    else:
                        result = MessageChain.fromMappingString(current, elem_mapping)

                    match.result = result
                    match.matched = bool(current)

                    if match.__class__ is RegexMatch:
                        match.regex_match = re.fullmatch(match.pattern, current)

                    if getattr(self, name, None) is None:
                        setattr(self, name, match)

            else:
                raise ValueError(f&#34;Regex not matching: {self._regex_pattern}&#34;)

    def get_help(self, description: str = &#34;&#34;, epilog: str = &#34;&#34;, *, header: bool = True) -&gt; str:

        formatter = self._parser._get_formatter()

        description = description or self._description
        formatter.add_text(description)

        if header:
            header: List[str] = [&#34;使用方法:&#34;]

            for match, *_ in self._list_check_match:
                header.append(match.get_help())

            for match, *_ in self._list_regex_match:
                header.append(match.get_help())

            formatter.add_usage(None, self._parser._actions, [], prefix=&#34; &#34;.join(header) + &#34; &#34;)

        positional, optional, *_ = self._parser._action_groups
        formatter.start_section(&#34;位置匹配&#34;)
        for match, _, name in self._list_regex_match:
            formatter.add_text(f&#34;{name} -&gt; 匹配 {match.get_help()}{&#39; : &#39; + match.help if match.help else &#39;&#39;}&#34;)
        formatter.add_arguments(positional._group_actions)
        formatter.end_section()

        formatter.start_section(&#34;参数匹配&#34;)
        formatter.add_arguments(optional._group_actions)
        formatter.end_section()

        epilog = epilog or self._epilog
        formatter.add_text(epilog)

        # determine help from format above
        return formatter.format_help()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.utils.Representation</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ariadne.message.parser.twilight.Sparkle.get_help"><code class="name flex">
<span>def <span class="ident">get_help</span></span>(<span>self, description: str = '', epilog: str = '', *, header: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_help(self, description: str = &#34;&#34;, epilog: str = &#34;&#34;, *, header: bool = True) -&gt; str:

    formatter = self._parser._get_formatter()

    description = description or self._description
    formatter.add_text(description)

    if header:
        header: List[str] = [&#34;使用方法:&#34;]

        for match, *_ in self._list_check_match:
            header.append(match.get_help())

        for match, *_ in self._list_regex_match:
            header.append(match.get_help())

        formatter.add_usage(None, self._parser._actions, [], prefix=&#34; &#34;.join(header) + &#34; &#34;)

    positional, optional, *_ = self._parser._action_groups
    formatter.start_section(&#34;位置匹配&#34;)
    for match, _, name in self._list_regex_match:
        formatter.add_text(f&#34;{name} -&gt; 匹配 {match.get_help()}{&#39; : &#39; + match.help if match.help else &#39;&#39;}&#34;)
    formatter.add_arguments(positional._group_actions)
    formatter.end_section()

    formatter.start_section(&#34;参数匹配&#34;)
    formatter.add_arguments(optional._group_actions)
    formatter.end_section()

    epilog = epilog or self._epilog
    formatter.add_text(epilog)

    # determine help from format above
    return formatter.format_help()</code></pre>
</details>
</dd>
<dt id="ariadne.message.parser.twilight.Sparkle.populate_arg_match"><code class="name flex">
<span>def <span class="ident">populate_arg_match</span></span>(<span>self, args: List[str]) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_arg_match(self, args: List[str]) -&gt; List[str]:
    if not self._mapping_arg_match:  # Optimization: skip if no ArgumentMatch
        return args
    namespace, rest = self._parser.parse_known_args(args)
    for arg_name, val_tuple in self._mapping_arg_match.items():
        match, sparkle_name = val_tuple
        namespace_val = getattr(namespace, arg_name, None)
        if arg_name in namespace.__dict__:
            match.result = namespace_val
            match.matched = bool(namespace_val)

        if getattr(self, sparkle_name, None) is None:
            setattr(self, sparkle_name, match)

    return rest</code></pre>
</details>
</dd>
<dt id="ariadne.message.parser.twilight.Sparkle.populate_check_match"><code class="name flex">
<span>def <span class="ident">populate_check_match</span></span>(<span>self, string: str, elem_mapping: Dict[int, <a title="ariadne.message.element.Element" href="../element.html#ariadne.message.element.Element">Element</a>]) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_check_match(self, string: str, elem_mapping: Dict[int, Element]) -&gt; List[str]:
    if not self._check_pattern:
        return split(string)
    if regex_match := self._check_regex.match(string):
        for match, index in self._list_check_match:
            current = regex_match.group(index) or &#34;&#34;
            if isinstance(match, ElementMatch):
                if current:
                    index = re.fullmatch(&#34;\x02(\\d+)_\\w+\x03&#34;, current).group(1)
                    result = elem_mapping[int(index)]
                else:
                    result = None
            else:
                result = MessageChain.fromMappingString(current, elem_mapping)

            match.result = result
            match.matched = bool(current)

            if match.__class__ is RegexMatch:
                match.regex_match = re.fullmatch(match.pattern, current)
        return split(string[regex_match.end() :])
    else:
        raise ValueError(f&#34;Not matching regex: {self._check_pattern}&#34;)</code></pre>
</details>
</dd>
<dt id="ariadne.message.parser.twilight.Sparkle.populate_regex_match"><code class="name flex">
<span>def <span class="ident">populate_regex_match</span></span>(<span>self, elem_mapping: Dict[str, <a title="ariadne.message.element.Element" href="../element.html#ariadne.message.element.Element">Element</a>], arg_list: List[str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_regex_match(self, elem_mapping: Dict[str, Element], arg_list: List[str]) -&gt; None:
    if self._regex_pattern:
        if regex_match := self._regex.fullmatch(&#34; &#34;.join(arg_list)):
            for match, index, name in self._list_regex_match:
                current = regex_match.group(index) or &#34;&#34;
                if isinstance(match, ElementMatch):
                    if current:
                        index = re.fullmatch(&#34;\x02(\\d+)_\\w+\x03&#34;, current).group(1)
                        result = elem_mapping[int(index)]
                    else:
                        result = None
                else:
                    result = MessageChain.fromMappingString(current, elem_mapping)

                match.result = result
                match.matched = bool(current)

                if match.__class__ is RegexMatch:
                    match.regex_match = re.fullmatch(match.pattern, current)

                if getattr(self, name, None) is None:
                    setattr(self, name, match)

        else:
            raise ValueError(f&#34;Regex not matching: {self._regex_pattern}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ariadne.message.parser.twilight.Twilight"><code class="flex name class">
<span>class <span class="ident">Twilight</span></span>
<span>(</span><span>root=Ellipsis, match=Ellipsis, *, map_params: Optional[Dict[str, bool]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>暮光.</p>
<p>Actual implementation of <strong>init</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Twilight(BaseDispatcher, Generic[T_Sparkle]):
    &#34;&#34;&#34;
    暮光.
    &#34;&#34;&#34;

    @overload
    def __init__(self, root: Dict[str, Match], *, map_params: Optional[Dict[str, bool]] = None):
        &#34;&#34;&#34;本魔法方法用于初始化本实例.

        Args:
            check (Dict[str, Match]): 匹配的映射.
            map_params (Dict[str, bool], optional): 向 MessageChain.asMappingString 传入的参数.
        &#34;&#34;&#34;

    @overload
    def __init__(
        self, root: Union[Type[T_Sparkle], T_Sparkle], *, map_params: Optional[Dict[str, bool]] = None
    ):
        &#34;&#34;&#34;本魔法方法用于初始化本实例.

        Args:
            root (Union[Type[Twilight], Twilight], optional): 根 Sparkle 实例, 用于生成新的 Sparkle.
            map_params (Dict[str, bool], optional): 向 MessageChain.asMappingString 传入的参数.
        &#34;&#34;&#34;

    @overload
    def __init__(
        self,
        root: Iterable[RegexMatch],
        match: Dict[str, Match] = ...,
        *,
        map_params: Optional[Dict[str, bool]] = None,
    ):
        &#34;&#34;&#34;本魔法方法用于初始化本实例.

        Args:
            check (Iterable[RegexMatch]): 用于检查的 Match 对象.
            match (Dict[str, Match]): 额外匹配的映射.
            map_params (Dict[str, bool], optional): 向 MessageChain.asMappingString 传入的参数.
        &#34;&#34;&#34;

    def __init__(self, root=..., match=..., *, map_params: Optional[Dict[str, bool]] = None):
        &#34;Actual implementation of __init__&#34;
        if isinstance(root, Sparkle):
            self.root = root
        elif isinstance(root, type) and issubclass(root, Sparkle):
            self.root = root()
        else:
            self.root = Sparkle(check=root, match=match)

        self._map_params = map_params or {}

    def generate(self, chain: MessageChain) -&gt; T_Sparkle:
        sparkle = deepcopy(self.root)
        mapping_str, elem_mapping = chain.asMappingString(**self._map_params)
        token = elem_mapping_ctx.set(chain)
        try:
            str_list = sparkle.populate_check_match(mapping_str, elem_mapping)
            arg_list = sparkle.populate_arg_match(str_list)
            sparkle.populate_regex_match(elem_mapping, arg_list)
        except Exception:
            raise
        elem_mapping_ctx.reset(token)
        return sparkle

    def beforeExecution(self, interface: &#34;DispatcherInterface[MessageEvent]&#34;):
        if not isinstance(interface.event, MessageEvent):
            raise ExecutionStop
        local_storage: _TwilightLocalStorage = interface.execution_contexts[-1].local_storage
        chain: MessageChain = interface.event.messageChain
        try:
            local_storage[&#34;result&#34;] = self.generate(chain)
        except:
            raise ExecutionStop

    async def catch(
        self, interface: &#34;DispatcherInterface[MessageEvent]&#34;
    ) -&gt; Optional[Union[&#34;Twilight&#34;, T_Sparkle, Match]]:
        local_storage: _TwilightLocalStorage = interface.execution_contexts[-1].local_storage
        sparkle = local_storage[&#34;result&#34;]
        if issubclass(interface.annotation, Sparkle):
            return sparkle
        if issubclass(interface.annotation, Twilight):
            return self
        if issubclass(interface.annotation, Match):
            if hasattr(sparkle, interface.name):
                match: Match = getattr(sparkle, interface.name)
                if isinstance(match, interface.annotation):
                    return match</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>graia.broadcast.entities.dispatcher.BaseDispatcher</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ariadne.message.parser.twilight.Twilight.mixin"><code class="name">var <span class="ident">mixin</span> : List[Union[graia.broadcast.entities.dispatcher.BaseDispatcher, Type[graia.broadcast.entities.dispatcher.BaseDispatcher]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ariadne.message.parser.twilight.Twilight.beforeExecution"><code class="name flex">
<span>def <span class="ident">beforeExecution</span></span>(<span>self, interface: DispatcherInterface[MessageEvent])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def beforeExecution(self, interface: &#34;DispatcherInterface[MessageEvent]&#34;):
    if not isinstance(interface.event, MessageEvent):
        raise ExecutionStop
    local_storage: _TwilightLocalStorage = interface.execution_contexts[-1].local_storage
    chain: MessageChain = interface.event.messageChain
    try:
        local_storage[&#34;result&#34;] = self.generate(chain)
    except:
        raise ExecutionStop</code></pre>
</details>
</dd>
<dt id="ariadne.message.parser.twilight.Twilight.catch"><code class="name flex">
<span>async def <span class="ident">catch</span></span>(<span>self, interface: DispatcherInterface[MessageEvent]) ‑> Union[<a title="ariadne.message.parser.twilight.Twilight" href="#ariadne.message.parser.twilight.Twilight">Twilight</a>, ~T_Sparkle, <a title="ariadne.message.parser.pattern.Match" href="pattern.html#ariadne.message.parser.pattern.Match">Match</a>, ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"><p>该方法可以是 <code>staticmethod</code>, <code>classmethod</code> 亦或是普通的方法/函数.
唯一的要求是 <code>Dispatcher.catch</code> 获取到的必须为一可调用异步 Callable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interface</code></strong> :&ensp;<code>DispatcherInterface</code></dt>
<dd><code>Dispatcher</code> 服务的主要对象, 可以从其中获取以下信息:</dd>
</dl>
<ul>
<li>当前解析中的参数的信息;</li>
<li>当前执行的信息, 比如正在处理的事件, <code>Listener</code>/<code>ExecTarget</code> etc.;</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def catch(
    self, interface: &#34;DispatcherInterface[MessageEvent]&#34;
) -&gt; Optional[Union[&#34;Twilight&#34;, T_Sparkle, Match]]:
    local_storage: _TwilightLocalStorage = interface.execution_contexts[-1].local_storage
    sparkle = local_storage[&#34;result&#34;]
    if issubclass(interface.annotation, Sparkle):
        return sparkle
    if issubclass(interface.annotation, Twilight):
        return self
    if issubclass(interface.annotation, Match):
        if hasattr(sparkle, interface.name):
            match: Match = getattr(sparkle, interface.name)
            if isinstance(match, interface.annotation):
                return match</code></pre>
</details>
</dd>
<dt id="ariadne.message.parser.twilight.Twilight.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, chain: <a title="ariadne.message.chain.MessageChain" href="../chain.html#ariadne.message.chain.MessageChain">MessageChain</a>) ‑> ~T_Sparkle</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate(self, chain: MessageChain) -&gt; T_Sparkle:
    sparkle = deepcopy(self.root)
    mapping_str, elem_mapping = chain.asMappingString(**self._map_params)
    token = elem_mapping_ctx.set(chain)
    try:
        str_list = sparkle.populate_check_match(mapping_str, elem_mapping)
        arg_list = sparkle.populate_arg_match(str_list)
        sparkle.populate_regex_match(elem_mapping, arg_list)
    except Exception:
        raise
    elem_mapping_ctx.reset(token)
    return sparkle</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ariadne.message.parser" href="index.html">ariadne.message.parser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ariadne.message.parser.twilight.Sparkle" href="#ariadne.message.parser.twilight.Sparkle">Sparkle</a></code></h4>
<ul class="">
<li><code><a title="ariadne.message.parser.twilight.Sparkle.get_help" href="#ariadne.message.parser.twilight.Sparkle.get_help">get_help</a></code></li>
<li><code><a title="ariadne.message.parser.twilight.Sparkle.populate_arg_match" href="#ariadne.message.parser.twilight.Sparkle.populate_arg_match">populate_arg_match</a></code></li>
<li><code><a title="ariadne.message.parser.twilight.Sparkle.populate_check_match" href="#ariadne.message.parser.twilight.Sparkle.populate_check_match">populate_check_match</a></code></li>
<li><code><a title="ariadne.message.parser.twilight.Sparkle.populate_regex_match" href="#ariadne.message.parser.twilight.Sparkle.populate_regex_match">populate_regex_match</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ariadne.message.parser.twilight.Twilight" href="#ariadne.message.parser.twilight.Twilight">Twilight</a></code></h4>
<ul class="">
<li><code><a title="ariadne.message.parser.twilight.Twilight.beforeExecution" href="#ariadne.message.parser.twilight.Twilight.beforeExecution">beforeExecution</a></code></li>
<li><code><a title="ariadne.message.parser.twilight.Twilight.catch" href="#ariadne.message.parser.twilight.Twilight.catch">catch</a></code></li>
<li><code><a title="ariadne.message.parser.twilight.Twilight.generate" href="#ariadne.message.parser.twilight.Twilight.generate">generate</a></code></li>
<li><code><a title="ariadne.message.parser.twilight.Twilight.mixin" href="#ariadne.message.parser.twilight.Twilight.mixin">mixin</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>